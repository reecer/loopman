{"version":3,"sources":["webpack:///webpack/bootstrap 724ac6740ba7f21e3971","webpack:///./src/constants.ts","webpack:///./src/loopManager.ts","webpack:///./src/loop.ts","webpack:///./src/clock.ts","webpack:///./src/dataChunks.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA,8CAA8C,cAAc;AAC5D,mBAAmB;AACnB;;;;;;;;ACHA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvFA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA","file":"lib/index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 724ac6740ba7f21e3971","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TICKS = 16; // ticks per measure\nexports.WORKER_URL = '../lib/worker.js';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants.ts\n// module id = 0\n// module chunks = 0 1","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst loop_1 = require(\"./loop\");\nconst clock_1 = require(\"./clock\");\nclass LoopManager {\n    constructor(bpm = 60) {\n        this.loops = [];\n        this.clock = new clock_1.Clock(bpm);\n        this.context = new AudioContext();\n        this._bpm = bpm;\n        this.clock.start();\n    }\n    // TODO: define `timing`\n    addLoop(name, counts) {\n        const l = new loop_1.Loop(name, this.context, this.clock, counts);\n        this.loops.push(l);\n        return l;\n    }\n    rmLoop(name) {\n        this.loops = this.loops.filter(l => l.name !== name);\n    }\n    stop() {\n        this.loops.forEach(l => l.stop());\n    }\n    set bpm(bpm) {\n        this._bpm = bpm;\n        this.clock.update(bpm);\n    }\n    get bpm() {\n        return this._bpm;\n    }\n}\nexports.LoopManager = LoopManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/loopManager.ts\n// module id = 1\n// module chunks = 0 1","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = require(\"./constants\");\nconst dataChunks_1 = require(\"./dataChunks\");\nclass Loop {\n    constructor(name, ctx, clk, counts, numChannels = 2) {\n        this.isPlaying = false;\n        this.isRecording = false;\n        this.name = name;\n        this.context = ctx;\n        this.clock = clk;\n        this.duration = counts;\n        this.volume = ctx.createGain();\n        this.processor = ctx.createScriptProcessor();\n        this.data = new dataChunks_1.DataChunks(numChannels);\n        this.volume.connect(ctx.destination);\n        this.processor.addEventListener('audioprocess', this.recv.bind(this));\n    }\n    // Pre-recorded audio\n    createBuffer(srcPath) {\n        throw \"TODO\";\n    }\n    // Live input\n    createStream() {\n        // TODO: polyfill\n        return navigator.mediaDevices.getUserMedia({ audio: true })\n            .then(stream => {\n            const source = this.context.createMediaStreamSource(stream);\n            source.connect(this.processor);\n            return source;\n        });\n    }\n    record(play = true) {\n        const START = 1;\n        const END = START + this.duration;\n        return new Promise((good, bad) => {\n            // Start recording at beginning of first measure\n            this.clock.listenOnce(START, () => {\n                this.isRecording = true;\n                this.processor.connect(this.volume);\n                // Stop recording at end\n                this.clock.listenOnce(END, () => {\n                    if (!this.isRecording) {\n                        // Stopped while recording\n                        return bad();\n                    }\n                    this.isRecording = false;\n                    this.processor.disconnect(this.volume);\n                    this.playback = this.data.asPlayback(this.context);\n                    if (play) {\n                        this.play(END + 1).then(() => good(this.playback));\n                    }\n                    else {\n                        good(this.playback);\n                    }\n                });\n            });\n        });\n    }\n    play(atTick = 1) {\n        this.playback.connect(this.context.destination);\n        this.playback.loop = true;\n        return new Promise(good => {\n            this.clock.listenOnce(atTick % constants_1.TICKS, () => {\n                this.playback.start();\n                this.isPlaying = true;\n                good();\n            });\n        });\n    }\n    stop() {\n        this.isRecording = false;\n        if (!this.playback) {\n            return;\n        }\n        this.playback.stop();\n        this.playback.disconnect(this.context.destination);\n        this.isPlaying = false;\n        console.log('Stopped playback');\n    }\n    recv(ev) {\n        if (!this.isRecording) {\n            return;\n        }\n        this.data.process(ev);\n    }\n}\nexports.Loop = Loop;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/loop.ts\n// module id = 2\n// module chunks = 0 1","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = require(\"./constants\");\nclass Clock {\n    constructor(bpm) {\n        this.worker = new Worker(constants_1.WORKER_URL);\n        this.currentTick = 1;\n        this.listeners = [];\n        this.worker.addEventListener('message', ev => this.tick(ev.data));\n        this.bpm = bpm;\n    }\n    tick(tickCount) {\n        this.currentTick = tickCount;\n        const cbs = this.listeners[tickCount];\n        if (cbs) {\n            cbs.forEach(cb => cb(tickCount));\n        }\n    }\n    update(bpm) {\n        if (bpm) {\n            this.bpm = bpm;\n        }\n        this.worker.postMessage(this.bpm);\n    }\n    start() {\n        this.update();\n    }\n    stop() {\n        this.worker.removeEventListener('message');\n    }\n    listenOnce(tickCount, callback) {\n        let idx = -1;\n        idx = this.addListener(tickCount, (t) => {\n            this.rmListener(tickCount, idx);\n            callback(t);\n        });\n    }\n    /*\n        Add the callback for the given tick.\n        Returns the index of the the listener;\n    */\n    addListener(tickCount, callback) {\n        if (!this.listeners[tickCount]) {\n            this.listeners[tickCount] = [];\n        }\n        const idx = this.listeners[tickCount].push(callback) - 1;\n        if (this.currentTick === tickCount) {\n            callback(this.currentTick);\n        }\n        return idx;\n    }\n    addListeners(tickCount, callback) {\n        return tickCount.map(tc => this.addListener(tc, callback));\n    }\n    /*\n        Remove the given index from `listeners`. As returned from `addListener`.\n    */\n    rmListener(tickCount, index) {\n        if (index < 0 || index >= this.listeners[tickCount].length) {\n            return;\n        }\n        this.listeners[tickCount].splice(index, 1);\n    }\n    rmListeners(tickCount, index) {\n        index.forEach(i => this.rmListener(tickCount, i));\n    }\n}\nexports.Clock = Clock;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/clock.ts\n// module id = 3\n// module chunks = 0 1","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass DataChunks {\n    constructor(numChannels) {\n        this.numChannels = numChannels;\n        this.chunksLength = 0;\n        this.chunks = [];\n        for (var i = 0; i < numChannels; i++) {\n            this.chunks.push(new Float32Array(0));\n        }\n    }\n    process(ev) {\n        for (var i = 0; i < this.numChannels; i++) {\n            let newChunks = ev.inputBuffer.getChannelData(i);\n            let oldChunks = this.chunks[i].slice();\n            this.chunks[i] = mergeBuffers([oldChunks, newChunks], oldChunks.length + newChunks.length);\n            console.log('processed channel', i, 'with length', newChunks.length);\n        }\n    }\n    asPlayback(ctx) {\n        let buf = ctx.createBuffer(this.numChannels, this.chunks[0].length, ctx.sampleRate);\n        for (var i = 0; i < this.numChannels; i++) {\n            buf.copyToChannel(this.chunks[i], i);\n        }\n        const src = ctx.createBufferSource();\n        src.buffer = buf;\n        return src;\n    }\n}\nexports.DataChunks = DataChunks;\nfunction mergeBuffers(recBuffers, recLength) {\n    let result = new Float32Array(recLength);\n    let offset = 0;\n    for (let i = 0; i < recBuffers.length; i++) {\n        result.set(recBuffers[i], offset);\n        offset += recBuffers[i].length;\n    }\n    return result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/dataChunks.ts\n// module id = 5\n// module chunks = 0 1"],"sourceRoot":""}